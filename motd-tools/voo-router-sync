#!/usr/bin/env python3
"""
VOO Router Device Sync

Connects to VOO Technicolor router and syncs device names to the
network-scan device_names.db file.

Usage:
    voo-router-sync           # Show devices from router
    voo-router-sync --update  # Update device_names.db
    voo-router-sync --json    # Output as JSON
"""

import requests
import json
import hashlib
import argparse
import sys
from pathlib import Path
from datetime import datetime
import configparser

# Configuration
CONFIG_DIR = Path.home() / "bin" / "config"
CONFIG_FILE = CONFIG_DIR / "router.conf"

# Paths
DATA_DIR = Path.home() / ".local" / "share" / "network-scan"
NAMES_FILE = DATA_DIR / "device_names.db"


def load_config():
    """Load configuration from router.conf file."""
    config = configparser.ConfigParser()
    
    if not CONFIG_FILE.exists():
        print(f"Error: Config file not found: {CONFIG_FILE}", file=sys.stderr)
        print(f"Copy {CONFIG_DIR}/router.conf.example to {CONFIG_FILE} and fill in your credentials.", file=sys.stderr)
        sys.exit(1)
    
    config.read(CONFIG_FILE)
    
    return {
        'url': config.get('router', 'url', fallback='http://192.168.0.1'),
        'username': config.get('router', 'username', fallback=''),
        'password': config.get('router', 'password', fallback=''),
    }


# Load config at module level
CONFIG = load_config()


def pbkdf2_hex(password: str, salt: str, iterations: int = 1000, key_length: int = 16) -> str:
    """Compute PBKDF2 hash and return as hex string."""
    if isinstance(password, str):
        password = password.encode('utf-8')
    if isinstance(salt, str):
        salt = salt.encode('utf-8')
    derived = hashlib.pbkdf2_hmac('sha256', password, salt, iterations, dklen=key_length)
    return derived.hex()


class VooRouter:
    """VOO Technicolor Router API client."""
    
    def __init__(self, url: str = None, username: str = None, password: str = None):
        url = url or CONFIG['url']
        username = username or CONFIG['username']
        password = password or CONFIG['password']
        self.url = url
        self.username = username
        self.password = password
        self.session = None
    
    def login(self) -> bool:
        """Authenticate with the router."""
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
            'Accept': 'application/json, text/javascript, */*; q=0.01',
            'X-Requested-With': 'XMLHttpRequest',
            'Referer': f'{self.url}/',
        })
        
        try:
            # Initialize session
            self.session.get(f"{self.url}/", timeout=10)
            self.session.get(f"{self.url}/api/v1/session/menu", timeout=10)
            
            # Get salt
            resp = self.session.post(
                f"{self.url}/api/v1/session/login",
                data={"username": self.username, "password": "seeksalthash"},
                timeout=10
            )
            data = resp.json()
            
            if data.get("error") != "ok":
                print(f"Error getting salt: {data.get('message')}", file=sys.stderr)
                return False
            
            salt = data.get("salt", "")
            salt_webui = data.get("saltwebui", "")
            
            # Compute password hash
            if salt == "none":
                final_password = self.password
            else:
                hashed1 = pbkdf2_hex(self.password, salt)
                final_password = pbkdf2_hex(hashed1, salt_webui)
            
            # Login
            resp = self.session.post(
                f"{self.url}/api/v1/session/login",
                data={"username": self.username, "password": final_password},
                timeout=10
            )
            data = resp.json()
            
            if data.get("error") != "ok":
                print(f"Login failed: {data.get('message')}", file=sys.stderr)
                return False
            
            # Set CSRF token
            csrf = self.session.cookies.get("auth", "")
            self.session.headers.update({'X-CSRF-TOKEN': csrf})
            
            # Activate session by getting menu
            self.session.get(f"{self.url}/api/v1/session/menu", timeout=10)
            
            return True
            
        except requests.RequestException as e:
            print(f"Connection error: {e}", file=sys.stderr)
            return False
    
    def get_devices(self) -> list:
        """Fetch list of connected devices."""
        if not self.session:
            return []
        
        try:
            resp = self.session.get(f"{self.url}/api/v1/host", timeout=30)
            data = resp.json()
            
            if data.get("error") == "ok":
                return data.get("data", {}).get("hostTbl", [])
            else:
                print(f"Error fetching devices: {data.get('message')}", file=sys.stderr)
                return []
                
        except requests.RequestException as e:
            print(f"Error fetching devices: {e}", file=sys.stderr)
            return []
    
    def logout(self):
        """Logout from router."""
        if self.session:
            try:
                self.session.post(f"{self.url}/api/v1/session/logout", timeout=5)
            except:
                pass


def get_connection_type(device: dict) -> str:
    """Determine connection type from layer1interface."""
    interface = device.get("layer1interface", "").lower()
    
    if "wifi" in interface:
        ssid = interface
        if "ssid.1" in interface:
            return "WiFi 2.4G"
        elif "ssid.2" in interface:
            return "WiFi 5G"
        else:
            return "WiFi"
    elif "ethernet" in interface:
        return "Ethernet"
    elif interface == "":
        return "Unknown"
    else:
        return interface


def load_existing_names() -> dict:
    """Load existing device names from database."""
    names = {}
    if NAMES_FILE.exists():
        with open(NAMES_FILE, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    parts = line.split('|', 1)
                    if len(parts) == 2:
                        names[parts[0].upper()] = parts[1]
    return names


def save_names(names: dict):
    """Save device names to database."""
    DATA_DIR.mkdir(parents=True, exist_ok=True)
    
    with open(NAMES_FILE, 'w') as f:
        f.write("# Custom Device Names\n")
        f.write("# Format: MAC|CUSTOM_NAME\n")
        f.write(f"# Last updated from VOO router: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write("# Add names with: scan --name MAC \"Device Name\"\n\n")
        
        for mac, name in sorted(names.items()):
            f.write(f"{mac}|{name}\n")


def main():
    parser = argparse.ArgumentParser(description="Sync device names from VOO router")
    parser.add_argument("--update", action="store_true", help="Update device_names.db")
    parser.add_argument("--json", action="store_true", help="Output as JSON")
    parser.add_argument("--active", action="store_true", help="Show only active devices")
    args = parser.parse_args()
    
    # Connect to router
    router = VooRouter()
    
    if not router.login():
        print("Failed to connect to router", file=sys.stderr)
        sys.exit(1)
    
    try:
        devices = router.get_devices()
        
        if not devices:
            print("No devices found", file=sys.stderr)
            sys.exit(1)
        
        # Filter active if requested
        if args.active:
            devices = [d for d in devices if d.get("active") == "true"]
        
        if args.json:
            # JSON output
            output = []
            for d in devices:
                output.append({
                    "mac": d.get("physaddress", "").upper(),
                    "ip": d.get("ipaddress", ""),
                    "hostname": d.get("hostname", ""),
                    "connection": get_connection_type(d),
                    "active": d.get("active") == "true",
                    "rssi": d.get("rssi", "-200"),
                })
            print(json.dumps(output, indent=2))
            
        elif args.update:
            # Update device_names.db
            existing = load_existing_names()
            new_count = 0
            updated_count = 0
            
            for d in devices:
                mac = d.get("physaddress", "").upper()
                hostname = d.get("hostname", "")
                
                # Skip if no hostname or hostname is just the MAC
                if not hostname or hostname.lower().replace(":", "") == mac.lower().replace(":", ""):
                    continue
                
                if mac not in existing:
                    existing[mac] = hostname
                    new_count += 1
                    print(f"  + Added: {mac} → {hostname}")
                elif existing[mac] != hostname:
                    # Only update if the new name is more descriptive
                    old_name = existing[mac]
                    # Keep custom names (they usually have spaces or special formatting)
                    if " " not in old_name and hostname != old_name:
                        existing[mac] = hostname
                        updated_count += 1
                        print(f"  ~ Updated: {mac}: {old_name} → {hostname}")
            
            save_names(existing)
            print(f"\n✓ Updated {NAMES_FILE}")
            print(f"  Total: {len(existing)} devices, New: {new_count}, Updated: {updated_count}")
            
        else:
            # Pretty print
            print(f"\n{'MAC Address':<20} {'IP Address':<16} {'Hostname':<28} {'Connection':<12} {'Active'}")
            print("=" * 90)
            
            for d in sorted(devices, key=lambda x: x.get("ipaddress", "")):
                mac = d.get("physaddress", "N/A").upper()
                ip = d.get("ipaddress", "N/A")
                hostname = d.get("hostname", "N/A")[:27]
                conn = get_connection_type(d)[:11]
                active = "✓" if d.get("active") == "true" else ""
                
                print(f"{mac:<20} {ip:<16} {hostname:<28} {conn:<12} {active}")
            
            print(f"\nTotal: {len(devices)} devices")
            active_count = sum(1 for d in devices if d.get("active") == "true")
            print(f"Active: {active_count} devices")
    
    finally:
        router.logout()


if __name__ == "__main__":
    main()
